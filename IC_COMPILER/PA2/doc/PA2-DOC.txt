Group Members:
- Eidan Spiegel; user: eidanspiegel; ID: 302122999
- Gleb Kodinetz; user: gelbkodi; ID: 322187378
- Yotam Frank; user: yotamfra; ID: 201268018

Code Structure

IC.lex is the lexer specification for Lexer.java which is used to process an input IC file into tokens.
IC.cup and Library.cup are both specification files for our parsers (Parser.java,LibraryParser.java) which are used to parse an IC program 
and generate it's abstract syntax tree (AST). 

Our main method (in Compiler.java):
1.	Parses the following command line arguments (can be given in any order): filename.ic [-Llibic.sig] [-print-ast] 
2.	Uses a Lexer.java scanner object to create parsers for the input IC program an IC lib files (optional).
3. 	Parses the said input IC files (according to the grammar of the IC language) and creates the corresponding ASTs.
4.	Prints the ASTs (optional).

Lexical errors are handled with the LexicalError class (see PA1-DOC for more details), and syntax errors are handled using
the SyntaxError class (see also Error Handling section).


Error Handling:

1.	If a mandatory argument wasn't given to the compiler, the program will exits with an appropriate message. 
2.	Also if there are a number of conflicting arguments given, again the program will exits with an appropriate message. 
3.	If a parser object has detected a syntax error, then a SyntaxError will be thrown specifing the line and token where the error has occured.
	We decided that the said token will be printed as is (for example ";" will be printed as ; and not as SEMI) because this way it will make more sense 
	for an ordinary person who might be using this compiler. see also Bonus I for more details on error handling and error recovery.


Testing Strategy:

We used the following files to test our Parser:
all_class.ic, all_expr.ic, all_liter.ic, all_meth.ic, all_ops.ic, all_stmt.ic,
empty_prog.ic, err_class1.ic, err_class2.ic, err_class3.ic, err_meth1.ic, err_meth2.ic,
err_meth3.ic and err_meth4.ic

We tested correct derivation rules according to the IC specification document. We also tested
for operator precedency and associativity. We also checked for correct error handling such as:
an empty file, various syntax and lexical errors.


Project Heirarchy:

Package IC:
Class Compiler: Contains the main method. Takes as input an IC program file (with an optional
IC Library file), parses it and creats an AST. It may also take an optional argument to use
pretty-printer on the AST.

package IC.AST:
Designed in accordance with the Visitor design pattern.
Contains all the objects that are used in the building of the AST. Each one of these objects extends
ASTNode which is the abstract generic node of the AST except for PrettyPrinter which implements the Visitor interface.
PrettyPrinter overloads the visit method inorder to properly handle all the different classes extending ASTNode. 

Package IC.Parser:
Class Lexer: The lexical analyzer generated by IC.lex using Jflex.
Class Parser: The syntactic parser generated by IC.cup using java_cup.
Class LibraryParser: The syntactic parser generated by Library.cup using java_cup.
Class LexicalError: An exception used for lexical errors.
Class SyntaxError: An exception used for syntax errors.
Class Token: Used by the class Lexer to generate appropriate tokens.
Class Sym: Contains static values of constants.


Grammar description (used with -dump_grammar argmument to java_cup)
Library.cup CUP grammar dump:

===== Terminals =====
[0]EOF [1]error [2]LP [3]RP [4]LB 
[5]RB [6]LCBR [7]RCBR [8]COMMA [9]DOT 
[10]SEMI [11]BOOLEAN [12]INTEGER [13]STRING [14]VOID 
[15]INT [16]NULL [17]EQUAL [18]NEQUAL [19]GT 
[20]GTE [21]LT [22]LTE [23]LNEG [24]LAND 
[25]LOR [26]FALSE [27]TRUE [28]MINUS [29]PLUS 
[30]MULTIPLY [31]MOD [32]DIVIDE [33]ASSIGN [34]UMINUS 
[35]STATIC [36]IF [37]ELSE [38]BREAK [39]CLASS 
[40]RETURN [41]CONTINUE [42]EXTENDS [43]THIS [44]WHILE 
[45]NEW [46]ID [47]CLASS_ID [48]QUOTE [49]LENGTH 


===== Non terminals =====
[0]libmethod [1]libmethod_list [2]formal [3]formal_list [4]libic 
[5]type 

===== Productions =====
[0] $START ::= libic EOF 
[1] type ::= INT 
[2] type ::= BOOLEAN 
[3] type ::= STRING 
[4] type ::= type LB RB 
[5] formal_list ::= formal 
[6] formal_list ::= formal_list COMMA formal 
[7] formal ::= type ID 
[8] libic ::= CLASS CLASS_ID LCBR libmethod_list RCBR 
[9] libmethod_list ::= libmethod 
[10] libmethod_list ::= libmethod_list libmethod 
[11] libmethod ::= STATIC type ID LP formal_list RP SEMI 
[12] libmethod ::= STATIC type ID LP RP SEMI 
[13] libmethod ::= STATIC VOID ID LP formal_list RP SEMI 
[14] libmethod ::= STATIC VOID ID LP RP SEMI 


IC.cup CUP grammar dump:
===== Terminals =====
[0]EOF [1]error [2]LP [3]RP [4]LB 
[5]RB [6]LCBR [7]RCBR [8]COMMA [9]DOT 
[10]SEMI [11]BOOLEAN [12]INTEGER [13]STRING [14]VOID 
[15]INT [16]NULL [17]EQUAL [18]NEQUAL [19]GT 
[20]GTE [21]LT [22]LTE [23]LNEG [24]LAND 
[25]LOR [26]FALSE [27]TRUE [28]MINUS [29]PLUS 
[30]MULTIPLY [31]MOD [32]DIVIDE [33]ASSIGN [34]UMINUS 
[35]STATIC [36]IF [37]ELSE [38]BREAK [39]CLASS 
[40]RETURN [41]CONTINUE [42]EXTENDS [43]THIS [44]WHILE 
[45]NEW [46]ID [47]CLASS_ID [48]QUOTE [49]LENGTH 


===== Non terminals =====
[0]program [1]literal [2]classDecl_list [3]classDecl [4]classbody_list 
[5]field [6]method [7]type [8]formals [9]formals_list 
[10]stmt [11]stmt_list [12]location [13]expr [14]expr_list 
[15]call [16]static_call [17]virtual_call [18]unop [19]binop 
[20]id_list 

===== Productions =====
[0] $START ::= program EOF 
[1] program ::= 
[2] program ::= classDecl_list 
[3] classDecl_list ::= classDecl 
[4] classDecl_list ::= classDecl_list classDecl 
[5] classDecl ::= CLASS CLASS_ID LCBR RCBR 
[6] classDecl ::= CLASS CLASS_ID EXTENDS CLASS_ID LCBR RCBR 
[7] classDecl ::= CLASS CLASS_ID LCBR classbody_list RCBR 
[8] classDecl ::= CLASS CLASS_ID EXTENDS CLASS_ID LCBR classbody_list RCBR 
[9] classbody_list ::= field 
[10] classbody_list ::= method 
[11] classbody_list ::= classbody_list method 
[12] classbody_list ::= classbody_list field 
[13] field ::= type id_list SEMI 
[14] id_list ::= ID 
[15] id_list ::= id_list COMMA ID 
[16] method ::= STATIC VOID ID LP RP LCBR stmt_list RCBR 
[17] method ::= STATIC type ID LP RP LCBR stmt_list RCBR 
[18] method ::= STATIC VOID ID LP formals_list RP LCBR stmt_list RCBR 
[19] method ::= STATIC type ID LP formals_list RP LCBR stmt_list RCBR 
[20] method ::= VOID ID LP RP LCBR stmt_list RCBR 
[21] method ::= type ID LP RP LCBR stmt_list RCBR 
[22] method ::= VOID ID LP formals_list RP LCBR stmt_list RCBR 
[23] method ::= type ID LP formals_list RP LCBR stmt_list RCBR 
[24] formals_list ::= formals 
[25] formals_list ::= formals_list COMMA formals 
[26] formals ::= type ID 
[27] type ::= STRING 
[28] type ::= INT 
[29] type ::= BOOLEAN 
[30] type ::= type LB RB 
[31] type ::= CLASS_ID 
[32] stmt_list ::= stmt 
[33] stmt_list ::= stmt_list stmt 
[34] stmt ::= location ASSIGN expr SEMI 
[35] stmt ::= call SEMI 
[36] stmt ::= RETURN SEMI 
[37] stmt ::= RETURN expr SEMI 
[38] stmt ::= IF LP expr RP stmt ELSE stmt 
[39] stmt ::= IF LP expr RP stmt 
[40] stmt ::= WHILE LP expr RP stmt 
[41] stmt ::= BREAK SEMI 
[42] stmt ::= CONTINUE SEMI 
[43] stmt ::= LCBR stmt_list RCBR 
[44] stmt ::= type ID SEMI 
[45] stmt ::= type ID ASSIGN expr SEMI 
[46] expr_list ::= expr 
[47] expr_list ::= expr_list COMMA expr 
[48] expr ::= location 
[49] expr ::= call 
[50] expr ::= THIS 
[51] expr ::= NEW CLASS_ID LP RP 
[52] expr ::= NEW type LB expr RB 
[53] expr ::= expr DOT LENGTH 
[54] expr ::= binop 
[55] expr ::= unop 
[56] expr ::= literal 
[57] expr ::= LP expr RP 
[58] call ::= static_call 
[59] call ::= virtual_call 
[60] static_call ::= CLASS_ID DOT ID LP RP 
[61] static_call ::= CLASS_ID DOT ID LP expr_list RP 
[62] virtual_call ::= ID LP RP 
[63] virtual_call ::= ID LP expr_list RP 
[64] virtual_call ::= expr DOT ID LP RP 
[65] virtual_call ::= expr DOT ID LP expr_list RP 
[66] location ::= ID 
[67] location ::= expr DOT ID 
[68] location ::= expr LB expr RB 
[69] binop ::= expr PLUS expr 
[70] binop ::= expr MINUS expr 
[71] binop ::= expr MULTIPLY expr 
[72] binop ::= expr DIVIDE expr 
[73] binop ::= expr MOD expr 
[74] binop ::= expr LAND expr 
[75] binop ::= expr LOR expr 
[76] binop ::= expr GT expr 
[77] binop ::= expr GTE expr 
[78] binop ::= expr LT expr 
[79] binop ::= expr LTE expr 
[80] binop ::= expr EQUAL expr 
[81] binop ::= expr NEQUAL expr 
[82] unop ::= MINUS expr 
[83] unop ::= LNEG expr 
[84] literal ::= QUOTE 
[85] literal ::= INTEGER 
[86] literal ::= TRUE 
[87] literal ::= FALSE 
[88] literal ::= NULL 

Bonus I:
We implemented error recovey behaviour by using the special "error" symbol (see CUP manual section 6) to derive errors as if they were ordinary
syntactic sturctures of the IC language. If an error occurs during derivation of some rule then the parser will try to find the last token of the 
right side of the said rule. If the said token is found, the parser will report the error and continue parsing from the next token. 
Otherwise a SyntaxError will be thrown and parsing will stop.

Bonus II:
To prevent declerations of local variables inside "if else" statements/"while" loops we divided stmt rule into two seperate rules:
stmt_minus_decl and declaration. Our syntax permits derivations of stmt_minus_decl only inside "if else" statements/"while" loop, and so,
if a declaration is encountered inside "if else" statements/"while" loop a SyntaxError will be thrown.

Feedback:
The exercise took us aprox. 3-4 days of joined work. The most difficult part was to reach the stage after parsing the library file. 
This was mainly due to compatability issues between JFlex and cup. The most interesting part was using the Visitor design pattern mainly due to
it's perceived usefulness in program design. One way this exercise can be made better would be to demonstrate in class how to parse a small .cup file.
We believe This could have saved us some trouble. 
