Group Members:

- Eidan Spiegel; user: eidanspiegel; ID: 302122999

- Gleb Kodinetz; user: gelbkodi; ID: 322187378

- Yotam Frank; user: yotamfra; ID: 201268018




Code Structure:

IC.lex is the lexer specification for Lexer.java which is used to process an input IC file into tokens.
 IC.cup and Library.cup are both specification files for our parsers (Parser.java,LibraryParser.java) which are used to parse an IC program 
and generate it's abstract syntax tree (AST).
SymbolTableBuilder is used to construct the GlobalSymbolTable which is then checked for semantic errors using SemanticChecker. We check for semantic rules such as type checking, scope rules, a class contains only one main method, break and continue statements appear only inside loops, etc.

Testing Strategy:
1) We tested on both example1.ic and example2.ic that were given with the assignment.
We checked that our output matches the correct output.
2) We tested Semantic Errors using various files that contain errors such as multiple main methods, break and continue statements outside loops and illegal type checking.

Project Hierarchy:


Project Heirarchy:



Package IC:
Class Compiler: Contains the main method. Takes as input an IC program file (with an optional
 IC Library file), parses it and creates an AST. It may also take an optional argument to use 
pretty-printer on the AST.

package. Afterwards creates a GlobalSymbolTable using SymbolTableBuilder and runs the SemanticChecker on it. May also take -dump-symtab as an argument and it will print the symbol tables.

Package IC.AST:

Designed in accordance with the Visitor design pattern.

Contains all the objects that are used in the building of the AST. Each one of these objects extends 
ASTNode which is the abstract generic node of the AST except for PrettyPrinter which implements the Visitor interface.


PrettyPrinter overloads the visit method inorder to properly handle all the different classes extending ASTNode.



Package IC.Parser:

Class Lexer: The lexical analyzer generated by IC.lex using Jflex.

Class Parser: The syntactic parser generated by IC.cup using java_cup.
Class LibraryParser: The syntactic parser generated by Library.cup using java_cup.

Class LexicalError: An exception used for lexical errors.

Class SyntaxError: An exception used for syntax errors.

Class Token: Used by the class Lexer to generate appropriate tokens.

Class Sym: Contains static values of constants.

BinaryOps, DataTypes, LiteralTypes and UnaryOps are all enumerated types used mainly in the IC.AST package.


Package IC.SymbolTable:
Class SymbolTable: Abstract class upon which all symbol tables extend.
Class GlobalSymbolTable: It extends SymbolTable and is the root of all the symbol table trees. This class is instanced only once throughout the compiler.
Class ClassSymbolTable: It extends SymbolTable and it stores all the fields and methods of a specific class. May hold ClassSymbolTable and MethodSymbolTable as its children.
Class BlockSymbolTable: It extends SymbolTable and stores all local variables of a specific code block. May have BlockSymbolTable as one of its children.
Class MethodSymbolTable: It extends SymbolTable and holds all the variables and return variable symbols of a specific method. May have BlockSymbolTable as one of its children.
Class Symbol: Abstract class upon which all other symbols extend.
Class ClassSymbol: Extends Symbol and represents a class entry in the GlobalSymbolTable.
Class MethodSymbol: Extends Symbol and represents a method entry in a ClassSymbolTable.
Class VarSymbol: Extends Symbol and represents a local variable entry in a MethodSymbolTable or a BlockSymbolTable.
Class FieldSymbol: Extends VarSymbol and represents a field entry in a ClassSymbolTable.

Package IC.TypeTable:
Class TypeTable: This class holds static fields for every type in the program: Primitive types, Array types, Method types and user defined class types. It has methods for adding and getting types, used by the SymbolTableBuilder when building the symbol tables, the SemanticChecker and the compiler for the type table dumping option.
Class Type: Abstract class upon which all other types extend.
Class ArrayType: Extends Type and represents an array type.
Class ClassType: Extends Type and represents a user defined class type.
Class MethodType: Extends Type and represents a method type.
Class IntType, BoolType, StringType, NullType, VoidType: Extend Type. Represent the primitive types.
Class SemanticError: Extends Exception. Used for throwing semantic errors.

Package IC.SemanticAnalysis:
Class SymbolTableBuilder: Implements the PropogatingVisitor class. Builds the symbol tables recursively from the AST.
Class SemanticChecker: Implements Visitor. Does all the semantic checks as detailed in the code structure.


Semantic Analysis:
The Semantic analysis is composed of two main parts: SymbolTableBuilder and SymanticChecker. The SymbolTableBuilder constructs all the symbol tables recursively: GlobalSymbolTable, ClassSymbolTable, MethodSymbolTable and BlockSymbolTable. It also inserts appropriate types into the TypeTable.
SemanticChecker is used to check the semantic rules of the IC language. We check for semantic rules such as type checking, scope rules, that a class contains exactly one main method, break and continue statements appear only inside loops, correct variable declarations, RHS and LHS in an assignment must havethe same type, a conditional test expression must be of type Boolean, no method overriding or illegal shadowing, correct usage of virtual and static calls, 'this' not being used from a static method.


Feedback:
We feel this assignment was incredibly hard. It took us about 40 hours of combined work. It was very hard in the begining to understand where to start and how to actually implement the symbol tables and visitors. If we were given a skeleton of some sort this might have helped us considerably and give us some starting momentum. We also feel that it is hard to check all possible semantic errors. Writing down all possible errors in a list somewhere might have been easier then trying to test again and again until you find or think of something new.
