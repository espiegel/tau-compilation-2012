package IC.Parser;

import IC.AST.*;
import IC.*;
import java.util.*;
import java_cup.runtime.*;


parser code {:

	// override method call in case of a (unrecovered) syntax error
	public void unrecovered_syntax_error(Symbol current_token) throws SyntaxError{
		throw new SyntaxError(current_token.left, current_token.value.toString());
		
	}
	
	// override method call in case of a syntax error, to avoid duplicate error messages
	public void syntax_error(Symbol current_token){}
:};

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

nonterminal Program program;
nonterminal Literal literal;
nonterminal List<ICClass> classDecl_list;
nonterminal ICClass classDecl;
nonterminal List<ASTNode> classbody_list;
nonterminal List<Field> field;
nonterminal Method method;
nonterminal Type type;
nonterminal Formal formals;
nonterminal List<Formal> formals_list;
nonterminal Statement stmt;
nonterminal List<Statement> stmt_list;
nonterminal Location location;
nonterminal Expression expr;
nonterminal List<Expression> expr_list;
nonterminal Call call;
nonterminal StaticCall static_call;
nonterminal VirtualCall virtual_call;
nonterminal UnaryOp unop;
nonterminal BinaryOp binop;
nonterminal List<String> id_list;
nonterminal Statement stmt_minus_decl;
nonterminal Statement declaration;

terminal LP, RP, LB, RB, LCBR, RCBR, COMMA, DOT, SEMI;
terminal BOOLEAN, INTEGER, STRING, VOID, INT, NULL;  /* types */
terminal EQUAL, NEQUAL, GT, GTE, LT, LTE,
         LNEG, LAND, LOR, FALSE, TRUE;               /* logic */      
terminal MINUS, PLUS, MULTIPLY, MOD, DIVIDE, ASSIGN, /* operators */
         UMINUS;
terminal STATIC, IF, ELSE, BREAK, CLASS, RETURN,
         CONTINUE, EXTENDS, THIS, WHILE, NEW;        /* keywords */
terminal String ID;
terminal String CLASS_ID;
terminal QUOTE, LENGTH;

//////////////////////////
// Precedence declarations
precedence left LB, RB, LP, RP, DOT;
precedence right UMINUS, LNEG;
precedence left MULTIPLY, DIVIDE, MOD; // Operators
precedence left LT, LTE, GT, GTE;      // Relational Operators
precedence left EQUAL, NEQUAL;         // Equality
precedence left PLUS, MINUS; 
precedence left LOR;
precedence left LAND;
precedence right ASSIGN;
precedence left IF, ELSE;

start with program;

//////////////
// The grammar

program ::= {: RESULT = new Program(new ArrayList<ICClass>()); :}
			| classDecl_list:c
            {: RESULT = new Program(c); :};

classDecl_list ::= classDecl:c
	{: List<ICClass> l = new ArrayList<ICClass>(); l.add(c); RESULT = l; :}
	| classDecl_list:clst classDecl:c
	{: clst.add(c); RESULT = clst; :};

         
classDecl ::= CLASS CLASS_ID:i LCBR RCBR
	{: RESULT = new ICClass(ileft, i, new ArrayList<Field>(), new ArrayList<Method>()); :}
	| CLASS CLASS_ID:i EXTENDS CLASS_ID:e LCBR RCBR
	{: RESULT = new ICClass(ileft, i, e, new ArrayList<Field>(), new ArrayList<Method>()); :}
	| CLASS:c CLASS_ID:i LCBR classbody_list:l RCBR
	{:  List<Method> methods = new ArrayList<Method>();
   		List<Field> fields = new ArrayList<Field>();
    	for(ASTNode a : l) {
        	if(a instanceof Method)
            	methods.add(((Method)a));
        	else if(a instanceof Field)
           		fields.add(((Field)a));
    	}
    	RESULT = new ICClass(cleft,i,fields,methods); 
	:}
	| CLASS:c CLASS_ID:i EXTENDS CLASS_ID:e LCBR classbody_list:l RCBR
	{:  List<Method> methods = new ArrayList<Method>();
   		List<Field> fields = new ArrayList<Field>();
    	for(ASTNode a : l) {
        	if(a instanceof Method)
            	methods.add(((Method)a));
        	else if(a instanceof Field)
           		fields.add(((Field)a));
    	}
    	RESULT = new ICClass(cleft,i,e,fields,methods); 
	:};

			
classbody_list ::= field:f
                  {: List<ASTNode> lf = new ArrayList<ASTNode>(); for(Field t : f) lf.add(t); RESULT=lf;  :}
                  | method:m
                  {: List<ASTNode> lm = new ArrayList<ASTNode>(); lm.add(m); RESULT=lm;  :}
                  | classbody_list:l method:m
                  {: l.add(m); RESULT = l; :}
                  | classbody_list:l field:f
                  {: for(Field t : f) l.add(t); RESULT = l; :};                 


field ::= type:t id_list:n SEMI 
          {: List<Field> list = new ArrayList<Field>();
             for(String id : n)
                 list.add(new Field(t,id));
             RESULT = list; :};
          
id_list ::= ID:id
	{: List<String> l = new ArrayList<String>(); l.add(id); RESULT = l; :}
	| id_list:l COMMA ID:id
	{: l.add(id); RESULT = l; :};

// 8 cases: 2 for void , 2 for static and 2 for formals.
method ::= STATIC VOID ID:id LP RP LCBR stmt_list:sl RCBR 
	{: RESULT = new StaticMethod(new PrimitiveType(idleft, DataTypes.VOID), id, new ArrayList<Formal>(), sl); :}
	| STATIC type:t ID:id LP RP LCBR stmt_list:sl RCBR
	{: RESULT = new StaticMethod(t, id, new ArrayList<Formal>(), sl); :}
	| STATIC VOID ID:id LP formals_list:fl RP LCBR stmt_list:sl RCBR
	{: RESULT = new StaticMethod(new PrimitiveType(idleft, DataTypes.VOID), id, fl, sl); :}
	| STATIC type:t ID:id LP formals_list:fl RP LCBR stmt_list:sl RCBR
	{: RESULT = new StaticMethod(t, id, fl, sl); :}
	| VOID ID:id LP RP LCBR stmt_list:sl RCBR 
	{: RESULT = new VirtualMethod(new PrimitiveType(idleft, DataTypes.VOID), id, new ArrayList<Formal>(), sl); :}
	| type:t ID:id LP RP LCBR stmt_list:sl RCBR
	{: RESULT = new VirtualMethod(t, id, new ArrayList<Formal>(), sl); :}
	| VOID ID:id LP formals_list:fl RP LCBR stmt_list:sl RCBR
	{: RESULT = new VirtualMethod(new PrimitiveType(idleft, DataTypes.VOID), id, fl, sl); :}
	| type:t ID:id LP formals_list:fl RP LCBR stmt_list:sl RCBR
	{: RESULT = new VirtualMethod(t, id, fl, sl); :};

formals_list ::= formals:l
				{: List<Formal> lf = new ArrayList<Formal>(); lf.add(l); RESULT=lf;  :}
				| formals_list:l COMMA formals:m
				{: l.add(m); RESULT = l; :};

formals ::= type:t ID:n
        {: RESULT = new Formal(t, n); :};

              
type ::= STRING:t
         {: RESULT = new PrimitiveType(tleft, DataTypes.STRING); :}
         | INT:t
         {: RESULT = new PrimitiveType(tleft, DataTypes.INT); :}
         | BOOLEAN:t
         {: RESULT = new PrimitiveType(tleft, DataTypes.BOOLEAN); :}
         | type:t LB RB
         {: t.incrementDimension(); RESULT = t; :}
         | CLASS_ID:t
         {: RESULT = new UserType(tleft, t); :};

stmt_list ::= stmt:s
	{: List<Statement> list = new ArrayList<Statement>(); list.add(s); RESULT = list; :}
	| stmt_list:sl stmt:s
	{: sl.add(s); RESULT = sl; :};
	
stmt ::= stmt_minus_decl:s1 
		{: RESULT = s1 :}
		| declaration:s2
		{: RESULT = s2 :};
		

stmt_minus_decl ::=  
	location:l ASSIGN expr:e SEMI
	{:	RESULT = new Assignment(l, e); :}
	| call:c SEMI
	{:	RESULT = new CallStatement(c); :}
	| RETURN:r SEMI
	{:	RESULT = new Return(rleft); :}
	| RETURN:r expr:e SEMI
	{:	RESULT = new Return(rleft, e); :}
	| IF LP expr:e RP stmt:s ELSE stmt:es
	{:	RESULT = new If(e, s, es); :}
	| IF LP expr:e RP stmt:s
	{:	RESULT = new If(e, s); :}
	| WHILE LP expr:e RP stmt:s
	{:	RESULT = new While(e, s); :}
	| BREAK:b SEMI
	{:	RESULT = new Break(bleft); :}
	| CONTINUE:c SEMI
	{:	RESULT = new Continue(cleft); :}
	| LCBR:lb stmt_list:sl RCBR
	{:	RESULT = new StatementsBlock(lbleft, sl); :};
	
declaration ::= type:t ID:id SEMI
	{:	RESULT = new LocalVariable(t, id); :}
	| type:t ID:id ASSIGN expr:e SEMI
	{:	RESULT = new LocalVariable(t, id, e); :};
	
expr_list ::= expr:e 
	{:	List<Expression> l = new ArrayList<Expression>(); l.add(e); RESULT = l; :}
	| expr_list:el COMMA expr:e
	{:	el.add(e); RESULT = el; :};

expr ::= location:l
	{:	RESULT = l; :}
	| call:c
	{:	RESULT = c; :}
	| THIS:t
	{:	RESULT = new This(tleft); :}
	| NEW CLASS_ID:c LP RP
	{:	RESULT = new NewClass(cleft, c); :}
	| NEW type:t LB expr:e RB
	{:	RESULT = new NewArray(t, e); :}
	| expr:e DOT LENGTH
	{:	RESULT = new Length(e); :}
	| binop:b
	{:	RESULT = b; :}
	| unop:u
	{:	RESULT = u; :}
	| literal:l
	{:	RESULT = l; :}
	| LP expr:e RP
	{:	RESULT = e; :};
		
call ::= static_call:call
         {: RESULT = call; :}
         | virtual_call:call
         {: RESULT = call; :};
         
static_call ::= CLASS_ID:c DOT ID:id LP RP
	{:	RESULT = new StaticCall(cleft, c, id, new ArrayList<Expression>()); :}
	| CLASS_ID:c DOT ID:id LP expr_list:el RP
	{:	RESULT = new StaticCall(cleft, c, id, el); :};

virtual_call ::= ID:id LP RP
	{:	RESULT = new VirtualCall(idleft, id, new ArrayList<Expression>()); :}
	|  ID:id LP expr_list:el RP
	{:	RESULT = new VirtualCall(idleft, id, el); :}
	| expr:e DOT ID:id LP RP
	{:	RESULT = new VirtualCall(idleft, e, id, new ArrayList<Expression>()); :}
	|  expr:e DOT ID:id LP expr_list:el RP
	{:	RESULT = new VirtualCall(idleft, e, id, el); :};

location ::= ID:id
	{:	RESULT = new VariableLocation(idleft, id); :}
	| expr:e DOT ID:id
	{:	RESULT = new VariableLocation(idleft, e, id); :}
	| expr:e1 LB expr:e2 RB
	{:	RESULT = new ArrayLocation(e1, e2); :};
	
binop ::= expr:e1 PLUS expr:e2
	{:	RESULT = new MathBinaryOp(e1, BinaryOps.PLUS, e2); :}
	| expr:e1 MINUS expr:e2
	{:	RESULT = new MathBinaryOp(e1, BinaryOps.MINUS, e2); :}
	| expr:e1 MULTIPLY expr:e2
	{:	RESULT = new MathBinaryOp(e1, BinaryOps.MULTIPLY, e2); :}
	| expr:e1 DIVIDE expr:e2
	{:	RESULT = new MathBinaryOp(e1, BinaryOps.DIVIDE, e2); :}
	| expr:e1 MOD expr:e2
	{:	RESULT = new MathBinaryOp(e1, BinaryOps.MOD, e2); :}
	| expr:e1 LAND expr:e2
	{:	RESULT = new LogicalBinaryOp(e1, BinaryOps.LAND, e2); :}
	| expr:e1 LOR expr:e2
	{:	RESULT = new LogicalBinaryOp(e1, BinaryOps.LOR, e2); :}
	| expr:e1 GT expr:e2
	{:	RESULT = new LogicalBinaryOp(e1, BinaryOps.GT, e2); :}
	| expr:e1 GTE expr:e2
	{:	RESULT = new LogicalBinaryOp(e1, BinaryOps.GTE, e2); :}
	| expr:e1 LT expr:e2
	{:	RESULT = new LogicalBinaryOp(e1, BinaryOps.LT, e2); :}
	| expr:e1 LTE expr:e2
	{:	RESULT = new LogicalBinaryOp(e1, BinaryOps.LTE, e2); :}
	| expr:e1 EQUAL expr:e2
	{:	RESULT = new LogicalBinaryOp(e1, BinaryOps.EQUAL, e2); :}
	| expr:e1 NEQUAL expr:e2
	{:	RESULT = new LogicalBinaryOp(e1, BinaryOps.NEQUAL, e2); :};

unop ::= MINUS expr:e
	{:	RESULT = new MathUnaryOp(UnaryOps.UMINUS, e); :} %prec UMINUS
	| LNEG expr:e
	{:	RESULT = new LogicalUnaryOp(UnaryOps.LNEG, e); :};  

literal ::=  QUOTE:q
	{:	RESULT = new Literal(qleft, LiteralTypes.STRING, q); :}
	| INTEGER:i
	{:	RESULT = new Literal(ileft, LiteralTypes.INTEGER, i); :}
	| TRUE:t
	{:	RESULT = new Literal(tleft, LiteralTypes.TRUE); :}
	| FALSE:f
	{:	RESULT = new Literal(fleft, LiteralTypes.FALSE); :}
	| NULL:n
	{:	RESULT = new Literal(nleft, LiteralTypes.NULL); :};