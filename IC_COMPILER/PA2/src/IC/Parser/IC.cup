package IC.Parser;

import IC.AST.*;
import IC.*;
import java.util.*;
import java_cup.runtime.*;


////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

nonterminal Program program;
nonterminal Literal literal;
nonterminal ICClass classDecl;
nonterminal List<ASTNode> classbody_list;
nonterminal Field field;
nonterminal Method method;
nonterminal Type methodtype;
nonterminal List<String> morefields;
nonterminal Type type;
nonterminal Formal formals;
nonterminal List<Formal> formals_list;
nonterminal List<Statement> stmt_list;


terminal LP, RP, LB, RB, LCBR, RCBR, COMMA, DOT, SEMI;
terminal BOOLEAN, INTEGER, STRING, VOID, INT, NULL;  /* types */
terminal EQUAL, NEQUAL, GT, GTE, LT, LTE,
         LNEG, LAND, LOR, FALSE, TRUE;               /* logic */      
terminal MINUS, PLUS, MULTIPLY, MOD, DIVIDE, ASSIGN; /* operators */
terminal STATIC, IF, ELSE, BREAK, CLASS, RETURN,
         CONTINUE, EXTENDS, THIS, WHILE, FOR, NEW;   /* keywords */
terminal String ID;
terminal CLASS_ID; // This is not a string.. it can also be a type.
terminal QUOTE, LENGTH;

//////////////////////////
// Precedence declarations

//start with program;

//////////////
// The grammar

literal ::= INTEGER:i
            {: RESULT = new Literal(((Token)i).getLine(), LiteralTypes.INTEGER, i); :}
            | NULL:i
            {: RESULT = new Literal(((Token)i).getLine(), LiteralTypes.NULL, i); :};


program ::= classDecl:c
            {: List<ICClass> l = new ArrayList<ICClass>(); l.add(c); RESULT = new Program(l); :};
            
classDecl ::= CLASS:c CLASS_ID:i LCBR classbody_list:l RCBR
{:  List<Method> methods = new ArrayList<Method>();
    List<Field> fields = new ArrayList<Field>();
    for(ASTNode a : l) {
       if(a instanceof Method)
           methods.add(((Method)a));
       else if(a instanceof Field)
           fields.add(((Field)a));
    }
    RESULT = new ICClass(((Token)c).getLine(), ((Token)i).getValueName(),fields,methods); 
:};
			
classbody_list ::= field:f
                  {: List<ASTNode> lf = new ArrayList<ASTNode>(); lf.add(f); RESULT=lf;  :}
                  | method:m
                  {: List<ASTNode> lm = new ArrayList<ASTNode>(); lm.add(m); RESULT=lm;  :}
                  | classbody_list:l method:m
                  {: l.add(m); RESULT = l; :}
                  | classbody_list:l field:f
                  {: l.add(f); RESULT = l; :};                 


field ::= type:t ID:n SEMI 
          {: RESULT = new Field(t,n); :}
          | field:f morefields:m SEMI
          {: for(String s : m)
                RESULT = new Field(f.getType(), s);
          :};
          
morefields ::= COMMA ID:n
               {: List<String> l = new ArrayList<String>(); l.add(n); RESULT=l; :}
               | morefields:m COMMA ID:n
               {: m.add(n); RESULT = m; :};


method ::= methodtype:t ID:n LP formals_list:f RP LCBR stmt_list:s RCBR
           {: RESULT = new VirtualMethod(t, n, f, s); :}
           | STATIC methodtype:t ID:n LP formals_list:f RP LCBR stmt_list:s RCBR
           {: RESULT = new StaticMethod(t, n, f, s); :};

formals_list ::= formals:l
				{: List<Formal> lf = new ArrayList<Formal>(); lf.add(l); RESULT=lf;  :}
				| formals_list:l COMMA formals:m
				{: l.add(m); RESULT = l; :};

formals ::= type:t ID:n
        {: RESULT = new Formal(t, n); :};

methodtype ::= type
              | VOID:t
              {: RESULT = new PrimitiveType(((Token)t).getLine(), DataTypes.VOID); :};
              
type ::= STRING:t
         {: RESULT = new PrimitiveType(((Token)t).getLine(), DataTypes.STRING); :}
         | INT:t
         {: RESULT = new PrimitiveType(((Token)t).getLine(), DataTypes.INT); :}
         | BOOLEAN:t
         {: RESULT = new PrimitiveType(((Token)t).getLine(), DataTypes.BOOLEAN); :}
         | type:t LB RB
         {: t.incrementDimension(); RESULT = t; :}
         | CLASS_ID:t
         {: RESULT = new UserType(((Token)t).getLine(), ((Token)t).getValueName()); :};

/*
//////////////////////////////////////////
// Eidan 7/12/12 - need to finish these 
//////////////////////////////////////////
stmt_list ::= stmt:s
	{: RESULT = new StmtList(s); :}
	| stmt_list:sl stmt:s
	{: sl.addStmt(s); RESULT = sl; :}
;

stmt ::= location '=' expr ';'
| call ';'
| return [expr] ';'
| if '(' expr ')' stmt
| break ';'
| continue ';'
| '{' stmt* '}'
| type ID['=' expr] ';';

expr ::= location
		| call
		| THIS
		| new CLASS '(' ')'
		| new type '[' expr ']'
		| expr '.' length
		| expr binop expr
		| unop expr
		| literal
		| '(' expr ')';
		
call ::= staticCall|virtualCall;
staticCall ::= CLASS '.' ID '(' [expr (',' expr)*] ')';
virtualCall ::= [expr'.'] ID '(' [expr (',' expr)*] ')';
location ::= ID | expr'.' ID | expr'[' expr ']';

binop ::= '+' | '-' | '*' | '/' | '%' | '&&' | '||' | '<'
		| '<' | '<=' | '>' | '>=' | '==' | '!=';
unop ::= '-' | '!';
literal ::= INTEGER | STRING | true | false | null;
*/