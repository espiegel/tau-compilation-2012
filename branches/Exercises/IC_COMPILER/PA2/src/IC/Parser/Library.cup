package IC.Parser;

import IC.AST.*;
import IC.*;
import java.util.*;
import java_cup.runtime.*;

parser code {:

	// override method call in case of a (unrecovered) syntax error
	public void unrecovered_syntax_error(Symbol current_token) throws SyntaxError{
		throw new SyntaxError(current_token.left, current_token.toString());
	}
	
	// override method call in case of a syntax error, to avoid duplicate error messages
	public void syntax_error(Symbol current_token){}
:};


/* Terminals */
terminal LP, RP, LB, RB, LCBR, RCBR, COMMA, DOT, SEMI;
terminal BOOLEAN, INTEGER, STRING, VOID, INT, NULL;  /* types */
terminal EQUAL, NEQUAL, GT, GTE, LT, LTE,
         LNEG, LAND, LOR, FALSE, TRUE;               /* logic */      
terminal MINUS, PLUS, MULTIPLY, MOD, DIVIDE, ASSIGN; /* operators */
terminal STATIC, IF, ELSE, BREAK, CLASS, RETURN,
         CONTINUE, EXTENDS, THIS, WHILE, FOR, NEW;   /* keywords */
terminal String ID;
terminal CLASS_ID; // This is not a string.. it can also be a type.
terminal QUOTE, LENGTH;


/* Non-Terminals */
nonterminal LibraryMethod libmethod;
nonterminal List<Method> libmethod_list;

nonterminal Formal formal;
nonterminal List<Formal> formal_list;

nonterminal ICClass libic;
nonterminal Type type;

precedence left LP, RP, LB, RB;

start with libic;

type ::= 
		INT:t 
 	 {: RESULT = (Type)(new PrimitiveType(tleft, DataTypes.INT)); :}  
 	 | BOOLEAN:t
 	 {: RESULT = (Type)(new PrimitiveType(tleft, DataTypes.BOOLEAN)); :} 
 	 | STRING:t
 	 {: RESULT = (Type)(new PrimitiveType(tleft, DataTypes.STRING)); :} 
 	 | type:t LB RB    /* array */ 
 	 {: t.incrementDimension(); RESULT = t; :}  ;

formal_list ::= formal:l
				{: List<Formal> lf = new ArrayList<Formal>(); lf.add(l); RESULT=lf;  :}
				| formal_list:l COMMA formal:m
				{: l.add(m); RESULT = l; :} ;

formal ::= type:t ID:n
        {: RESULT = new Formal(t, n); :} ;

libic ::= CLASS:c CLASS_ID LCBR libmethod_list:l RCBR
		{: RESULT = new ICClass(cleft,"Library",new ArrayList<Field>(),l); :} ;

libmethod_list ::= libmethod:l
				{: List<Method> lf = new ArrayList<Method>(); lf.add(l); RESULT=lf; :}
				| libmethod_list:l libmethod:m
				{: l.add(m); RESULT = l; :} ;
				
libmethod ::= STATIC type:t ID:mid LP formal_list:formlst RP SEMI
          {: RESULT = new LibraryMethod(t, (String)mid, formlst); :}
          |   STATIC type:t ID:mid LP RP SEMI
          {: RESULT = new LibraryMethod(t, (String)mid, new ArrayList<Formal>()); :}
          |   STATIC VOID ID:mid LP formal_list:formlst RP SEMI
          {: RESULT = new LibraryMethod((Type)(new PrimitiveType(midleft, DataTypes.VOID)), (String)mid, formlst); :}  
          |   STATIC VOID ID:mid LP RP SEMI
          {: RESULT = new LibraryMethod((Type)(new PrimitiveType(midleft, DataTypes.VOID)), (String)mid, new ArrayList<Formal>()); :} 
          ; 
            
            